{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)d2a59d60-9351-44eb-8889-f883ec3c7c98","ParentGuid":"(Guid)c6490cda-40b4-40bf-aca3-a5070b47f989","Name":"(string)Init_Master","Properties":{"@Type":"2c41fa04:IDictionary","@Value":{}},"TypeGuid":"(Guid)8ac092e5-3128-4e26-9e7e-11016c6684f2","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"8ac092e5","@Value":{"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)(* System generated code, could be modified for your application *)\n\n(* Standard interface *)\nastSubModuleInterface[c_udiMaster].i_sModuleName\t:= STANDARD.CONCAT(STR1 := iq_stStandardModuleItf.i_sModuleName, STR2 := ': Master');\n\nastSubModuleInterface[c_udiMaster].i_xLogEnable\t\t:= TRUE;\nastSubModuleInterface[c_udiMaster].i_wLogDataFilter\t:= UDINT_TO_WORD(TPL.ET_LogDataFilter.ModuleDefault);\n\n(* AxisModule specific interface *)\nstMasterInterface.stMain.i_ifMaster\t\t:= i_ifMaster; \t\t(* Master *)\nstMasterInterface.stMain.i_ifDrive\t\t:= DRV_Master;\nstMasterInterface.stMain.iq_lencEncoder\t:= LE_Master;\t\n\n\nxDriveIsVirtual := FC_IsDriveVirtual(\ti_ifDrive\t:= stMasterInterface.stMain.i_ifDrive,\n\t\t\t\t\t\t\t\t\t\tq_etDiag\t=> etDiag,\n\t\t\t\t\t\t\t\t\t\tq_etDiagExt\t=> etDiagExt, //etDiagExtTPL,\n\t\t\t\t\t\t\t\t\t\tq_sMsg\t\t=> sMsgBuffer);\n\nIF etDiag <> GD.ET_Diag.Ok AND NOT xIsDriveVirtualException THEN\t\t\t\t\t\t\t\t\t\t\n\tstIsDriveVirtualException.sMsg := sMsgBuffer;\n\txIsDriveVirtualException := TRUE;\nEND_IF\n\nTPL.FC_SetException(i_xExceptionActive\t:= xIsDriveVirtualException, \n\t\t\t\t\tiq_stException\t\t:= stIsDriveVirtualException, \n\t\t\t\t\tiq_stExceptionList\t:= iq_stExceptionList, \n\t\t\t\t\tiq_stLogDataList\t:= iq_stLogDataList);\n\t\t\t\t\t\nxInitSuccessful := xInitSuccessful AND NOT xIsDriveVirtualException;\netDiag := GD.ET_Diag.Ok;\n\t\n\n(*Set DeadTime compensation parameters depending on used type of Master*)\nFC_SetDeadTimeCompensation(i_stSubModuleInterfaceMain := stMasterInterface.stMain);\n  (*Please note, FC_DeadTimeCompensation does not recognize the master type, transferred via C2C or encoder network! \n\tstXXXXInterface.stMain.iq_lencEncoder.Delay must be adjusted in order to reach shaft synchronism, it depends on:\n\t- Transmission delay via the choosen network, depending on topology and timing \n\t- Type of the master e.g. physical encoder or an axis\n\t- SERCOS cycle times in master and slave controllers\n\t\n\tC2C sample (similar for encoder network):\n\t//Access C2C_EncIn.DataDelay only if C2C_Master.SyncGroupState=5 or C2C_Slave.SyncGroupState = 5 and C2C_EncIn.DataValid = TRUE!\n\n\t\t//Master is a physical encoder (PMEnc/Inc):\n\t\t\tstXXXXInterface.stMain.iq_lencEncoder.Delay := C2C_EncIn.DataDelay - DRV_SlaveAxis.ShaftRefDelay;\n\n\t\t//Master is an axis (real/ virtual):\n\t\t\tstXXXXInterface.stMain.iq_lencEncoder.Delay := C2C_EncIn.DataDelay + one SERCOS cycle of C2C controller with connected master axis;*)\n\n\nstMasterInterface.stMain.i_lrMotionActiveVelLimit\t\t\t\t\t\t:= 15.0;\t\t(* Limit for max. velocity of astAxisModuleInterface to switch output AxisMove in Units/s *)\nstMasterInterface.stMain.i_etMotionActiveVelType\t\t\t\t\t\t:= AXM.ET_MotionActiveVelType.Velocity;\n\nstMasterInterface.stMain.i_timMasterStop\t\t\t\t\t\t\t\t:= T#1S;\nstMasterInterface.stMain.i_xHwLimitPos\t\t\t\t\t\t\t\t\t:= FALSE;\nstMasterInterface.stMain.i_xHwLimitNeg\t\t\t\t\t\t\t\t\t:= FALSE;\n\nstMasterInterface.stMain.stReducedVelocity.i_xEnableReducedVelocity\t\t:= FALSE;\nstMasterInterface.stMain.stReducedVelocity.i_xOnlyLimitCheck\t\t\t:= FALSE;\nstMasterInterface.stMain.stReducedVelocity.i_lrMaxReducedVelocity\t\t:= 50.0;\n\nstMasterInterface.stMain.i_xStart\t\t\t\t\t\t\t\t\t\t:= FALSE;\n\n(***************************************************************************************************************************************************************************************************)\n\n(*** Homing ***)\t\t\n\t\t\t\t\t\t\t\nIF xDriveIsVirtual THEN\n\tstMasterInterface.stHome.i_etMode := PDL.ET_HomeMode.SetPosAxisAndLogEncoderPosition;\t\t(* Homing Mode in case of virtual axis *)\nELSE\n\tstMasterInterface.stHome.i_etMode := PDL.ET_HomeMode.PosDirectionPosEdgeTp;\t\t\t\t\t(* Homing Mode in case of real axis *)\nEND_IF\n\n\nstMasterInterface.stHome.i_xEnableInitAbsReadPos := TRUE;\t\t\t\t\t\t(* TRUE : Restores the AxisPosition depending on the stHome.etMode\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  If stHome.i_etMode is equal to PDL.ET_HomeMode.RestorePosFromAxisEncoder or \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  to PDL.ET_HomeMode.WriteAxisEncoder, the encoder of the axis is read,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  or else the position will be restored from the retain area *)\n\nstMasterInterface.stHome.stSetpos.iq_pstRestorePosRetain := ADR(Grp_stRestorePositionAxis1);\n\nstMasterInterface.stHome.i_xResetHomeOk := FALSE;\n\n(* Possible modes for homing mode Sensor:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeSensor\n\tPDL.ET_HomeMode.NegDirectionPosEdgeSensor\n\tPDL.ET_HomeMode.NegDirectionNegEdgeSensor\n\tPDL.ET_HomeMode.PosDirectionNegEdgeSensor\n*)\nstMasterInterface.stHome.stSensor.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstMasterInterface.stHome.stSensor.i_lrVel\t\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstMasterInterface.stHome.stSensor.i_lrAcc\t\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstMasterInterface.stHome.stSensor.i_lrDec\t\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstMasterInterface.stHome.stSensor.i_lrJerk\t\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstMasterInterface.stHome.stSensor.i_lrOffset\t\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstMasterInterface.stHome.stSensor.i_lrMaxTravel \t\t\t:= 720.0;\t\t(* Max. travel for referencing by normal input *)\nstMasterInterface.stHome.stSensor.i_xRotativeSystem\t\t\t:= FALSE;\t\t(* Rotative system true or false for referencing by normal input *)\nstMasterInterface.stHome.stSensor.i_xSensor \t\t\t\t:= FALSE;\t\t(* Input for home signal. Can be a signal from a controller input. Has to be written cyclic. *)\n\n(* Possible Modes for homing mode LimitSwitch:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeHWLimitPos\t\tnormally open contact / Closing contact\n\tPDL.ET_HomeMode.NegDirectionPosEdgeHWLimitNeg\t\tnormally open contact / Closing contact\n\tPDL.ET_HomeMode.NegDirectionNegEdgeHWLimitNeg\t\tnormally closed contact / Opening contact  \n\tPDL.ET_HomeMode.PosDirectionNegEdgeHWLimitPos\t\tnormally closed contact / Opening contact \n*)\nstMasterInterface.stHome.stLimitSwitch.i_lrHomePosition \t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstMasterInterface.stHome.stLimitSwitch.i_lrVel\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstMasterInterface.stHome.stLimitSwitch.i_lrLowVel\t\t\t:= 5.0;\t\t\t(* Homing low ceiling velocity in units/s *)\nstMasterInterface.stHome.stLimitSwitch.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstMasterInterface.stHome.stLimitSwitch.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstMasterInterface.stHome.stLimitSwitch.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstMasterInterface.stHome.stLimitSwitch.i_lrOffset\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstMasterInterface.stHome.stLimitSwitch.i_lrMaxTravel \t\t:= 9999.0;\t\t(* Max. travel for referencing normal input as a hardware limit *)\n\n(* Possible modes for homing mode MoveOnPos:\n\tPDL.ET_HomeMode.MoveOnPosAbs \n*)\nstMasterInterface.stHome.stMoveOnPos.i_lrTarget\t\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstMasterInterface.stHome.stMoveOnPos.i_lrVel\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstMasterInterface.stHome.stMoveOnPos.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstMasterInterface.stHome.stMoveOnPos.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstMasterInterface.stHome.stMoveOnPos.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstMasterInterface.stHome.stMoveOnPos.i_lrPeriod\t\t\t\t:= 0.0;\t\t\t(* Period of the axis *)\nstMasterInterface.stHome.stMoveOnPos.i_xRotativeSystem\t\t:= FALSE;\t\t(* Rotative system true or false *)\n\n(* Possible modes for homing mode SetPos:\n\tPDL.ET_HomeMode.SetPosAxisPosition \n\tPDL.ET_HomeMode.SetPosLogEncoderPosition \n\tPDL.ET_HomeMode.SetPosAxisAndLogEncoderPosition\n\tPDL.ET_HomeMode.RestorePosFromAxisEncoder \n\tPDL.ET_HomeMode.RestorePosFromRetain \n*)\nstMasterInterface.stHome.stSetpos.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstMasterInterface.stHome.stSetpos.i_lrEncoderPosition\t\t:= 0.0;\t\t\t(* Encoder position in units after homing *)\nstMasterInterface.stHome.stSetpos.i_lrAbsEncOffset\t\t\t:= 100.0;\t\t(* Distance to the jump of axis encoder in units *)\nstMasterInterface.stHome.stSetpos.i_lrRestoreWindow\t\t\t:= 180;\t\t\t(* How far can the drive be away from its correct position *)\nstMasterInterface.stHome.stSetpos.i_lrUserPeriod\t\t\t:= 360;\t\t\t(* Period of the axis *)\n\n(* Possible modes for homing mode Torque:\n\tPDL.ET_HomeMode.PosDirectionMaxTorque \n\tPDL.ET_HomeMode.NegDirectionMaxTorque \n*)\nstMasterInterface.stHome.stTorque.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstMasterInterface.stHome.stTorque.i_lrVel\t\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstMasterInterface.stHome.stTorque.i_lrAcc\t\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstMasterInterface.stHome.stTorque.i_lrDec\t\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstMasterInterface.stHome.stTorque.i_lrJerk\t\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstMasterInterface.stHome.stTorque.i_lrOffset\t\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstMasterInterface.stHome.stTorque.i_lrMaxTravel\t\t\t\t:= 9999.0;\t\t(* Max. travel for referencing by torque *)\nstMasterInterface.stHome.stTorque.i_lrMaxTorque\t\t\t\t:= 0.0;\t\t\t(* Torque for stop in Nm / referencing by torque *)\nstMasterInterface.stHome.stTorque.i_diTorqueTime\t\t\t:= 5;\t\t\t(* Time in msec to hold torque *)\n\n(* Possible modes for homing mode TouchProbe:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeTp \n\tPDL.ET_HomeMode.NegDirectionPosEdgeTp \n\tPDL.ET_HomeMode.NegDirectionNegEdgeTp \n\tPDL.ET_HomeMode.PosDirectionNegEdgeTp \n*)\nstMasterInterface.stHome.stTouchProbe.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstMasterInterface.stHome.stTouchProbe.i_lrVel\t\t\t\t:= 100.0;\t\t(* Homing ceiling velocity in units/s *)\nstMasterInterface.stHome.stTouchProbe.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstMasterInterface.stHome.stTouchProbe.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstMasterInterface.stHome.stTouchProbe.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstMasterInterface.stHome.stTouchProbe.i_lrOffset\t\t\t:= 30.0;\t\t(* Offset from home signal in units *)\nstMasterInterface.stHome.stTouchProbe.i_lrMaxTravel\t\t\t:= 720.0;\t\t(* Max. travel for referencing by TP *)\nstMasterInterface.stHome.stTouchProbe.i_xRotativeSystem\t\t:= TRUE;\t\t(* Rotative system true or false for referencing by TP *)\nstMasterInterface.stHome.stTouchProbe.i_ifTouchProbe\t\t:= TP_0;\t\t(* Input for TP *)\n\n(* Possible modes for homing mode WritePos:\n\tPDL.ET_HomeMode.WriteAxisEncoder \n*)\nstMasterInterface.stHome.stWritePos.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstMasterInterface.stHome.stWritePos.i_lrUserPeriod\t\t\t:= 0.0;\t\t\t(* Calculates Drive.Position into period ( units ) *)\nstMasterInterface.stHome.stWritePos.i_lrAbsEncOffset\t\t:= 100.0;\t\t(* Distance to the jump of axis encoder in units *)\n\n(***************************************************************************************************************************************************************************************************)\n(*** Manual ***)\n\nstMasterInterface.stManual.i_lrVel\t\t\t\t\t\t\t\t:= 50.0;\t\t\t(* Velocity in units/s *)\nstMasterInterface.stManual.i_lrAcc\t\t\t\t\t\t\t\t:= 100.0;\t\t\t(* Acceleration in units/s^2 *)\nstMasterInterface.stManual.i_lrDec\t\t\t\t\t\t\t\t:= 100.0;\t\t\t(* Deceleration in units/s^2 *)\nstMasterInterface.stManual.i_lrJerk\t\t\t\t\t\t\t\t:= 1000.0;\t\t\t(* Jerk in units/s^3 *)\nstMasterInterface.stManual.i_lrMaxDistance\t\t\t\t\t\t:= 120.0;\t\t\t(* Max pathlengths for one step in units *)\nstMasterInterface.stManual.i_xEndless\t\t\t\t\t\t\t:= FALSE;\t\t\t(* TRUE: jogging endless; Position between the periode; FALSE: jogging in steps. Position can be out of periode *)\nstMasterInterface.stManual.i_lrPeriod\t\t\t\t\t\t\t:= 360.0;\t\t\t(* Period of the axis *)\n\n(***************************************************************************************************************************************************************************************************)\n(*** Cam ***)\n\nstMasterInterface.stMultiCam.i_etCSModeSlave\t\t\t\t\t:= PDL.ET_MultiCamCsModeSlave.SetSlavePositionToFirstCamPosition;\t\t(* ColdStartMode Slave *)\nstMasterInterface.stMultiCam.i_etCSModeMaster\t\t\t\t\t:= PDL.ET_MultiCamCsModeMaster.SetMasterPositionToFirstCamPosition;\t\t(* ColdStartMode Master *)\nstMasterInterface.stMultiCam.i_etWSMode\t\t\t\t\t\t\t:= PDL.ET_MultiCamWsMode.StoredCamMoveAlwaysNoPositionCheck;\t\t\t(* WarmStartMode *)\nstMasterInterface.stMultiCam.i_lrWSWindow\t\t\t\t\t\t:= 5.0;\t\t\t\t\t\t\t\t\t\t\t(* WarmStartWindow in Axis units *)\nstMasterInterface.stMultiCam.i_lrWSVel\t\t\t\t\t\t\t:= 10.0;\t\t\t\t\t\t\t\t\t\t(* Velocity for WarmStart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in Units/s *)\nstMasterInterface.stMultiCam.i_lrWSAcc\t\t\t\t\t\t\t:= 1000.0;\t\t\t\t\t\t\t\t\t\t(* Acceleration and deceleration for Warmstart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in Units/s^2 *)\nstMasterInterface.stMultiCam.i_lrWSJerk\t\t\t\t\t\t\t:= 10000.0;\t\t\t\t\t\t\t\t\t\t(* Jerk for Warmstart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in units/s^3 *)\nstMasterInterface.stMultiCam.i_diTXend\t\t\t\t\t\t\t:= 2*SYSTEMINTERFACE.FC_LzsTaskGetInterval();\t(* Time of XLowEnd and XHighEnd befor Xend or Xstart in msec*)\nstMasterInterface.stMultiCam.i_lrInstantXLimMax\t\t\t\t\t:= 0.0;\t\t\t\t\t\t\t\t\t\t\t(* Switch off position at 'InstantNewCam' *)\n\nstMasterInterface.stMultiCam.i_xEnableTabHandler\t\t\t\t:= TRUE;\t\t\t\t\t\t\t\t\t\t(* TRUE: TabHandler is enabled *)\nstMasterInterface.stMultiCam.i_udiTableSelectNr\t\t\t\t\t:= AXM.ET_ParId.User;\t\t\t\t\t\t\t(* Number of table which is used in the next cycle *)\t\t\t\t\t\t\t\t\n\nstMasterInterface.stMultiCam.i_xSetEncoderParameters\t\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: The parameters MasterId, FeedConstand, GearIn and GearOut will be copyed into LEnc object *)\nstMasterInterface.stMultiCam.i_xSetEncoderPosition\t\t\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: Manipulation of LEnc object on startup OpMode MultiCam *)\nstMasterInterface.stMultiCam.i_lrSetEncoderOffset\t\t\t\t:= 0.0;\t\t\t\t\t\t\t\t\t\t\t(* Master encoder offset *)\nstMasterInterface.stMultiCam.i_xCheckEncoderPeriod\t\t\t\t:= TRUE;\t\t\t\t\t\t\t\t\t\t(* TRUE: Check of encoder period = 0. If encoder period <> 0 -> Exception *)\n\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].diNumberOfCamPoints\t\t\t:= 4;\t(* DataStruct for the next cycle *)\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].lrYPeriod\t\t\t\t\t:= 0.0;\n\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrX\t\t\t:= 0.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrY\t\t\t:= 0.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrM\t\t\t:= 0.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].etCamType\t:= PDL.ET_CamType.Poly5Com;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrX\t\t\t:= 60.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrY\t\t\t:= 30.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrM\t\t\t:= 1.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].etCamType\t:= PDL.ET_CamType.Straight;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrX\t\t\t:= 240.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrY\t\t\t:= 210.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrM\t\t\t:= 1.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].etCamType\t:= PDL.ET_CamType.Poly5Com;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrX\t\t\t:= 360.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrY\t\t\t:= 0.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrM\t\t\t:= 0.0;\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].etCamType\t:= PDL.ET_CamType.Poly5Com;\n\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Idle].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Idle);\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Start].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Start);\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Cont].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Cont);\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Stop].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Stop);\nstMasterInterface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.User);\n\n\n(***************************************************************************************************************************************************************************************************)\n(*** Endless ***)\n\nstMasterInterface.stEndless.i_lrVel\t\t\t\t\t\t\t\t:= 100.0;\t\t\t(* Velocity in Units/s *)\nstMasterInterface.stEndless.i_lrAcc\t\t\t\t\t\t\t\t:= 1000.0;\t\t\t(* Acceleration in Units/s^2 *)\nstMasterInterface.stEndless.i_lrDec\t\t\t\t\t\t\t\t:= 1000.0;\t\t\t(* Deceleration in Units/s^2 *)\nstMasterInterface.stEndless.i_lrJerk\t\t\t\t\t\t\t:= 10000.0;\t\t\t(* Jerk in units/s^3 *)\nstMasterInterface.stEndless.i_lrPeriod\t\t\t\t\t\t\t:= 360.0;\t\t\t(* Period one cycle in units *)\nstMasterInterface.stEndless.i_lrStopPosition\t\t\t\t\t:= 0.5;\t\t\t\t(* Stop position in units *)\n\n\n(***************************************************************************************************************************************************************************************************)\n(*** Pos ***)\n\nstMasterInterface.stPos.i_etPosMode\t\t\t\t\t\t\t\t:= SYSTEMINTERFACE.ET_PosMode.Endless;\t\t(* SYSTEMINTERFACE.ET_PosMode.Endless, SYSTEMINTERFACE.ET_PosMode.Relative, SYSTEMINTERFACE.ET_PosMode.Absolute *)\nstMasterInterface.stPos.i_lrTarget\t\t\t\t\t\t\t\t:= 360.0;\t\t\t\t\t\t\t\t\t(* Target position or distance in Units *)\nstMasterInterface.stPos.i_lrVel\t\t\t\t\t\t\t\t\t:= 360.0;\t\t\t\t\t\t\t\t\t(* Ceiling velocity in Units/s *)\nstMasterInterface.stPos.i_lrAcc\t\t\t\t\t\t\t\t\t:= 3600.0;\t\t\t\t\t\t\t\t\t(* Acceleration in Units/s^2 *)\nstMasterInterface.stPos.i_lrDec\t\t\t\t\t\t\t\t\t:= 3600.0;\t\t\t\t\t\t\t\t\t(* Deceleration in Units/s^2 *)\nstMasterInterface.stPos.i_lrJerk\t\t\t\t\t\t\t\t:= 36000.0;\t\t\t\t\t\t\t\t\t(* Jerk in units/s^3 *)\n\n(* End of system generated code, could be modified for your application *)\n","LineInfoPersistence":"(string)d2a59d60-9351-44eb-8889-f883ec3c7c98_Impl_LineIds"}}}},"UniqueIdGenerator":"(string)1133"}},"TypeInfos":{"3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","8ac092e5":"{8ac092e5-3128-4e26-9e7e-11016c6684f2}","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}