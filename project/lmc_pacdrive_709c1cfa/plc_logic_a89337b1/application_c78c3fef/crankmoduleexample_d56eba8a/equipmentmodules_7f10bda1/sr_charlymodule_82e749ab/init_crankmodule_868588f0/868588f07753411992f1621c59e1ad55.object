{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)868588f0-7753-4119-92f1-621c59e1ad55","ParentGuid":"(Guid)82e749ab-50e2-4743-bacb-f425c721768a","Name":"(string)Init_CrankModule","Properties":{"@Type":"2c41fa04:IDictionary","@Value":{}},"TypeGuid":"(Guid)8ac092e5-3128-4e26-9e7e-11016c6684f2","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"8ac092e5","@Value":{"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)(* Standard interface *)\nastSubModuleInterface[c_udiCrank].i_sModuleName:= Standard.CONCAT(STR1:= iq_stStandardModuleItf.i_sModuleName, STR2:= ': CrankModule');\n\n(*\n\tCrank module interface \n*)\n\nstCrankModuleItf.stMain.i_ifDriveCrank\t\t\t:= DRV_CrankDrive;\nstCrankModuleItf.stMain.iq_lencEncoderCrank\t\t:= LE_EncCrank;\n\nstCrankModuleItf.stMain.i_ifDriveSlide\t\t\t:= DRV_SlideDrive;\nstCrankModuleItf.stMain.iq_lencEncoderSlide\t\t:= LE_EncSlide;\n\nstCrankModuleItf.stMain.i_ifMaster\t\t\t\t:= DRV_Master;\n\n\nstCrankModuleItf.stMain.i_lrMotionActiveVelLimit\t:= 15.0;\t\t(* Limit for max. velocity of astAxisModuleInterface  to switch output AxisMove in Units/s *)\nstCrankModuleItf.stMain.i_etMotionActiveVelType\t\t:= CRKM.ET_MotionActiveVelType.RefVelocity;\n\n\n(***************************************************************************************************************************************************************************************************)\n(*** Homing ***)\n\nstCrankModuleItf.stHome.stTouchProbe.i_ifTouchProbe\t:= TP_1;\n\nstCrankModuleItf.stHome.i_etMode\t\t\t\t\t:= PDL.ET_HomeMode.SetPosAxisAndLogEncoderPosition;\t(* Homing Mode in case of real axis *)\n\nstCrankModuleItf.stHome.i_xEnableInitAbsReadPos\t\t:= FALSE;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(* TRUE : Restores the AxisPosition depending on the stHome.etMode\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t if stHome.etMode is equal PDL.ET_HomeMode.RestorePosFromAxisencoder or \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t PDL.ET_HomeMode.WriteAxisEncoder, the encoder of the axis is read,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t or else the position will be restored from the retain area*)\nstCrankModuleItf.stHome.stSetpos.iq_pstRestorePosRetain\t:= ADR(Grp_stRestorePositionAxisCrank);\n\n(* Possible modes for homing mode Sensor:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeSensor\n\tPDL.ET_HomeMode.NegDirectionPosEdgeSensor\n\tPDL.ET_HomeMode.NegDirectionNegEdgeSensor\n\tPDL.ET_HomeMode.PosDirectionNegEdgeSensor\n*)\nstCrankModuleItf.stHome.stSensor.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstCrankModuleItf.stHome.stSensor.i_lrVel\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstCrankModuleItf.stHome.stSensor.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstCrankModuleItf.stHome.stSensor.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstCrankModuleItf.stHome.stSensor.i_lrJerk\t\t\t\t:= 100000.0;\t(* Homing jerk in units/s^3 *)\nstCrankModuleItf.stHome.stSensor.i_lrOffset\t\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstCrankModuleItf.stHome.stSensor.i_lrMaxTravel\t\t\t:= 720.0;\t\t(* Max. travel for refering by  normal input *)\nstCrankModuleItf.stHome.stSensor.i_xRotativeSystem\t\t:= FALSE;\t\t(* Rotative system true or false for refering by normal input *)\n\n(* Possible Modes for homing mode LimitSwitch:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeHWLimitPos\t\tnormally open contact / Closing contact\n\tPDL.ET_HomeMode.NegDirectionPosEdgeHWLimitNeg\t\tnormally open contact / Closing contact\n\tPDL.ET_HomeMode.NegDirectionNegEdgeHWLimitNeg\t\tnormally closed contact / Opening contact  \n\tPDL.ET_HomeMode.PosDirectionNegEdgeHWLimitPos\t\tnormally closed contact / Opening contact \n*)\nstCrankModuleItf.stHome.stLimitSwitch.i_lrHomePosition\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstCrankModuleItf.stHome.stLimitSwitch.i_lrVel\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstCrankModuleItf.stHome.stLimitSwitch.i_lrAcc\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstCrankModuleItf.stHome.stLimitSwitch.i_lrDec\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstCrankModuleItf.stHome.stLimitSwitch.i_lrOffset\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstCrankModuleItf.stHome.stLimitSwitch.i_lrMaxTravel\t\t:= 9999.0;\t\t(* Max. travel for referencing normal input as a hardware limit *)\nstCrankModuleItf.stHome.stLimitSwitch.i_lrJerk\t\t\t:= 1000000.0;\t(* Homing jerk in units/s^3 *)\n\n(* Possible modes for homing mode MoveOnPos:\n\tPDL.ET_HomeMode.MoveOnPosAbs \n*)\nstCrankModuleItf.stHome.stMoveonPos.i_lrTarget\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstCrankModuleItf.stHome.stMoveonPos.i_lrVel\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstCrankModuleItf.stHome.stMoveonPos.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstCrankModuleItf.stHome.stMoveonPos.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstCrankModuleItf.stHome.stMoveonPos.i_xRotativeSystem\t:= FALSE;\t\t(* Rotative system true or false *)\nstCrankModuleItf.stHome.stMoveonPos.i_lrPeriod\t\t\t:= 0.0;\t\t\t(* Period of the axis *)\nstCrankModuleItf.stHome.stMoveonPos.i_lrJerk\t\t\t:= 1000000.0;\t(* Homing jerk in units/s^3 *)\n\n(* Possible modes for homing mode SetPos:\n\tPDL.ET_HomeMode.SetPosAxisPosition \n\tPDL.ET_HomeMode.SetPosLogEncoderPosition \n\tPDL.ET_HomeMode.SetPosAxisAndLogEncoderPosition\n\tPDL.ET_HomeMode.RestorePosFromAxisEncoder \n\tPDL.ET_HomeMode.RestorePosFromRetain \n*)\nstCrankModuleItf.stHome.stSetpos.i_lrHomePosition\t\t:= 100.0;\t\t(* Position at the end of homing in units *)\nstCrankModuleItf.stHome.stSetpos.i_lrEncoderPosition\t:= 0.0;\t\t\t(* Encoder position in units after homing *)\nstCrankModuleItf.stHome.stSetpos.i_lrAbsEncOffset\t\t:= 100.0;\t\t(* Distance to the jump of axis encoder in units  *)\nstCrankModuleItf.stHome.stSetpos.i_lrRestoreWindow\t\t:= 180;\t\t\t(* How far can the drive be away from is correct position *)\nstCrankModuleItf.stHome.stSetpos.i_lrUserPeriod\t\t\t:= 360;\t\t\t(* Period of the axis *)\n\n(* Possible modes for homing mode Torque:\n\tPDL.ET_HomeMode.PosDirectionMaxTorque \n\tPDL.ET_HomeMode.NegDirectionMaxTorque \n*)\nstCrankModuleItf.stHome.stTorque.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstCrankModuleItf.stHome.stTorque.i_lrVel\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstCrankModuleItf.stHome.stTorque.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstCrankModuleItf.stHome.stTorque.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstCrankModuleItf.stHome.stTorque.i_lrOffset\t\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstCrankModuleItf.stHome.stTorque.i_lrMaxTravel\t\t\t:= 9999.0;\t\t(* Max. travel for referencing by TP or normal input *)\nstCrankModuleItf.stHome.stTorque.i_lrMaxTorque\t\t\t:= 0.0;\t\t\t(* Torque for stop in Nm / referencing by torque *)\nstCrankModuleItf.stHome.stTorque.i_lrJerk\t\t\t\t:= 1000000.0;\t(* Homing jerk in units/s^3 *)\nstCrankModuleItf.stHome.stTorque.i_diTorqueTime\t\t\t:= 5;\t\t\t(* Time in msec to hold torque *)\n\n(* Possible modes for homing mode TouchProbe:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeTp \n\tPDL.ET_HomeMode.NegDirectionPosEdgeTp \n\tPDL.ET_HomeMode.NegDirectionNegEdgeTp \n\tPDL.ET_HomeMode.PosDirectionNegEdgeTp \n*)\nstCrankModuleItf.stHome.stTouchProbe.i_lrHomePosition\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstCrankModuleItf.stHome.stTouchProbe.i_lrVel\t\t\t:= 100.0;\t\t(* Homing ceiling velocity in units/s *)\nstCrankModuleItf.stHome.stTouchProbe.i_lrAcc\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstCrankModuleItf.stHome.stTouchProbe.i_lrDec\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstCrankModuleItf.stHome.stTouchProbe.i_lrOffset\t\t\t:= 30.0;\t\t(* Offset from home signal in units *)\nstCrankModuleItf.stHome.stTouchProbe.i_lrMaxTravel\t\t:= 720.0;\t\t(* Max. travel for referencing by TP or normal input *)\nstCrankModuleItf.stHome.stTouchProbe.i_xRotativeSystem\t:= TRUE;\t\t(* Rotative system true or false for referencing by TP *)\nstCrankModuleItf.stHome.stTouchProbe.i_lrJerk\t\t\t:= 1000000.0;\t(* Homing jerk in units/s^3 *)\n\n(* Possible modes for HomeWritePos:\n\tPDL.ET_HomeMode.WriteAxisEncoder\n*)\nstCrankModuleItf.stHome.stWritePos.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstCrankModuleItf.stHome.stWritePos.i_lrUserPeriod\t\t:= 0.0;\t\t\t(* Calculates Drive.position into period ( units ) *)\nstCrankModuleItf.stHome.stWritePos.i_lrAbsEncOffset\t\t:= 180.0;\t\t(* Distance to the jump of axis encoder in units *)\n\n(***************************************************************************************************************************************************************************************************)\n(*** Manual ***)\nstCrankModuleItf.stManual.i_xCrankMode\t\t\t\t\t:= FALSE;\t\t\t(* TRUE: Jogging CrankAxis, FALSE: Jogging SlideAxis *)\nstCrankModuleItf.stManual.i_lrVel\t\t\t\t\t\t:= 25.0;\t\t\t(* Velocity in units/s *)\nstCrankModuleItf.stManual.i_lrAcc\t\t\t\t\t\t:= 100.0;\t\t\t(* Acceleration in units/s^2 *)\nstCrankModuleItf.stManual.i_lrDec\t\t\t\t\t\t:= 100.0;\t\t\t(* Deceleration in units/s^2 *)\nstCrankModuleItf.stManual.i_lrMaxDistance\t\t\t\t:= 120.0;\t\t\t(* Max pathlengths for one step in units *)\nstCrankModuleItf.stManual.i_xEndless\t\t\t\t\t:= FALSE;\t\t\t(* TRUE: jogging endless; Position between the periode; FALSE: jogging in steps. Position can be out of periode *)\nstCrankModuleItf.stManual.i_lrJerk\t\t\t\t\t\t:= 10000.0;\t\t\t(* Jerk in units/s^3 *)\n\n(***************************************************************************************************************************************************************************************************)\n(*** Cam ***)\n\nstCrankModuleItf.stMultiCam.i_etCSModeSlave\t\t\t\t:= PDL.ET_MultiCamCsModeSlave.SetSlavePositionToFirstCamPosition;\t(* ColdStartMode Axis *)\nstCrankModuleItf.stMultiCam.i_etCSModeMaster\t\t\t:= PDL.ET_MultiCamCsModeMaster.SetMasterPositionToFirstCamPosition;\t(* ColdStartMode Master *)\nstCrankModuleItf.stMultiCam.i_etWSMode\t\t\t\t\t:= PDL.ET_MultiCamWsMode.StoredCamMoveAlwaysNoPositionCheck;\t\t(* WarmStartMode *)\nstCrankModuleItf.stMultiCam.i_lrWSWindow\t\t\t\t:= 5.0;\t\t\t\t\t\t\t\t(* WarmStartWindow in Axis units *)\nstCrankModuleItf.stMultiCam.i_lrWSVel\t\t\t\t\t:= 100.0;\t\t\t\t\t\t\t(* Velocity for WarmStart and CSModeAxis = 2 in Units/s *)\nstCrankModuleItf.stMultiCam.i_lrWSAcc\t\t\t\t\t:= 1000.0;\t\t\t\t\t\t\t(* Acceleration and deceleration for Warmstart  and CSModeAxis = 2 in Units/s2 *)\nstCrankModuleItf.stMultiCam.i_lrWSJerk\t\t\t\t\t:= 10000.0;\nstCrankModuleItf.stMultiCam.i_diTXend\t\t\t\t\t:= 2 * SystemInterface.FC_LzsTaskGetInterval();\t\t\t(* Time of XLowEnd and XHighEnd befor Xend or Xstart in msec*)\nstCrankModuleItf.stMultiCam.i_lrInstantXLimMax\t\t\t:= 0.0;\t\t\t\t\t\t\t\t(* Switch off position at 'InstantNewCam' *)\n\nstCrankModuleItf.stMultiCam.i_xEnableTabHandler\t\t\t:= TRUE;\nstCrankModuleItf.stMultiCam.i_udiTableSelectNr\t\t\t:= DINT_TO_UDINT(CRKM.ET_ParId.User);\n\nstCrankModuleItf.stMultiCam.i_xSetEncoderParameters\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: The parameters MasterId, FeedConstand, GearIn and GearOut will be copyed into LEnc object *)\nstCrankModuleItf.stMultiCam.i_xSetEncoderPosition\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: Manipulation of LEnc object on startup OpMode MultiCam *)\nstCrankModuleItf.stMultiCam.i_lrSetEncoderOffset\t\t:= 0.0;\t\t\t\t\t\t\t\t\t\t\t(* Master encoder offset *)\nstCrankModuleItf.stMultiCam.i_xCheckEncoderPeriod\t\t:= TRUE;\t\t\t\t\t\t\t\t\t\t(* TRUE: Check of encoder period = 0. If encoder period <> 0 -> Exception *)\n\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].diNumberOfCamPoints\t\t\t:= 4;\t(* DataStruct for the next cycle *)\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].lrYPeriod\t\t\t\t\t:= 0.0;\n\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[0].lrX\t\t\t:= 0.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[0].lrY\t\t\t:= 0.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[0].lrM\t\t\t:= 0.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[0].etCamType\t:= PDL.ET_CamType.Poly5Com;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[1].lrX\t\t\t:= 60.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[1].lrY\t\t\t:= 30.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[1].lrM\t\t\t:= 1.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[1].etCamType\t:= PDL.ET_CamType.Straight;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[2].lrX\t\t\t:= 240.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[2].lrY\t\t\t:= 210.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[2].lrM\t\t\t:= 1.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[2].etCamType\t:= PDL.ET_CamType.Poly5Com;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[3].lrX\t\t\t:= 360.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[3].lrY\t\t\t:= 0.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[3].lrM\t\t\t:= 0.0;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].astCamPoint[3].etCamType\t:= PDL.ET_CamType.Poly5Com;\n\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.Idle].diUserTableId\t\t\t\t:= CRKM.ET_ParId.Idle;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.Start].diUserTableId\t\t\t\t:= CRKM.ET_ParId.Start;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.Cont].diUserTableId\t\t\t\t:= CRKM.ET_ParId.Cont;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.Stop].diUserTableId\t\t\t\t:= CRKM.ET_ParId.Stop;\nstCrankModuleItf.stMultiCam.iq_astMotionPar[CRKM.ET_ParId.User].diUserTableId\t\t\t\t:= CRKM.ET_ParId.User;\n\n(***************************************************************************************************************************************************************************************************)\n(*** Endless ***)\n\n(* ENDLESS parameters need to remain at sensible values so that it reaches a velocity of at least 10.0 within 100ms*)\nstCrankModuleItf.stEndless.i_lrVel\t\t\t\t:= 100.0;\t\t\t(* Velocity in units/s *)\nstCrankModuleItf.stEndless.i_lrAcc\t\t\t\t:= 1000.0;\t\t\t(* Acceleration in units/s^2 *)\nstCrankModuleItf.stEndless.i_lrDec\t\t\t\t:= 1000.0;\t\t\t(* Deceleration in units/s^2 *)\nstCrankModuleItf.stEndless.i_lrPeriod\t\t\t:= 360.0;\t\t\t(* Period one cycle in units *)\nstCrankModuleItf.stEndless.i_lrStopPosition\t\t:= 0.5;\t\t\t\t(* Stop position in units ( if G_eStart = FALSE ) *)\nstCrankModuleItf.stEndless.i_lrJerk\t\t\t\t:= 10000.0;\n\n(***************************************************************************************************************************************************************************************************)\n(*** Pos ***)\n\nstCrankModuleItf.stPos.i_etPosMode\t\t\t\t:= SystemInterface.ET_PosMode.Relative;\t\t\t(* POS_ENDLESS, POS_RELATIVE, POS_ABSOLUTE *)\nstCrankModuleItf.stPos.i_lrTarget\t\t\t\t:= -360.0;\t\t\t\t\t(* Target position or distance in units *)\nstCrankModuleItf.stPos.i_lrVel\t\t\t\t\t:= 100.0;\t\t\t\t\t(* Ceiling velocity in units/s *)\nstCrankModuleItf.stPos.i_lrAcc\t\t\t\t\t:= 3600.0;\t\t\t\t\t(* Acceleration in units/s^2 *)\nstCrankModuleItf.stPos.i_lrDec\t\t\t\t\t:= 3600.0;\t\t\t\t\t(* Deceleration in units/s^2 *)\nstCrankModuleItf.stPos.i_lrJerk\t\t\t\t\t:= 99999.0;\t\t\t\t\t(* Jerk in units/s^3 *)\n\n(***************************************************************************************************************************************************************************************************)\n(*** Crank Transformation Data \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t ***)\n(***************************************************************************************************************************************************************************************************)\n\nstCrankModuleItf.stCrank.lrRadius\t\t\t\t\t\t\t\t\t\t\t:= 50.0;\t(* Crank radius *)\nstCrankModuleItf.stCrank.lrPushRod\t\t\t\t\t\t\t\t\t\t\t:= 157.2;\t(* Length *)\nstCrankModuleItf.stCrank.lrOffset\t\t\t\t\t\t\t\t\t\t\t:= 0.0;\t(* Distance crank center to slide level *)\nstCrankModuleItf.stCrank.lrXStart\t\t\t\t\t\t\t\t\t\t\t:= 7.2;\t(* Distance crank center to 0-position of slide *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\nstCrankModuleItf.stCrank.diXLogEqualXMechRange\t:= 1;\t\t\t(* Range where logical position equals mechanical position of slide *)\n\nstCrankModuleItf.stCrank.xCrankLeft\t\t\t\t\t\t\t\t\t\t\t:= FALSE;\t(* TRUE = Crank on the left hand side *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(* FALSE = Crank on the right hand side *)\n\nstCrankModuleItf.stCrank.xRange\t\t\t\t\t\t\t\t\t\t\t\t:= FALSE;\t(* if TRUE and two ranges, then take range 1 *)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(* if FALSE and two ranges, then take range 2 *)\n\nstCrankModuleItf.stCrank.lrP5Pole1IntervalLow\t:= 0.5;\t(* Distance X pole 1 <-> low end of interpolation interval *)\nstCrankModuleItf.stCrank.lrP5Pole1IntervalHigh\t:= 0.5;\t(* Distance X pole 1 <-> high end of interpolation interval *)\nstCrankModuleItf.stCrank.lrP5Pole2IntervalLow\t:= 0.5;\t(* Distance X pole 2 <-> low end of interpolation interval *)\nstCrankModuleItf.stCrank.lrP5Pole2IntervalHigh\t:= 0.5;\t(* Distance X pole 2 <-> high end of interpolation interval *)\nstCrankModuleItf.stCrank.lrP5RangeLow\t\t\t:= 2.0;\t(* only for overlapping interpolation intervals: definition range of start polynomial *)\nstCrankModuleItf.stCrank.lrP5RangeHigh\t\t\t:= 2.0;\t(* only for overlapping interpolation intervals: definition range of end polynomial *)\n\nstCrankModuleItf.stCrank.lrUserMechPosOffset\t:= 0.0;\t\t(* Offset for user-defined mechanical crank position *)\nstCrankModuleItf.stCrank.lrUserMechPosDirection\t:= 1.0;\t\t(* Direction for user-defined mechanical crank position *)\n\n(* Calculated mechanical crank data *)\nstCrankModuleItf.stCrank.diNumberOfRanges\t\t:= 0;\t\t\t(* in certain mechanical configurations it is possible to have two ranges *)\nstCrankModuleItf.stCrank.xEndlessCrank\t\t\t:= FALSE;\t\t(* TRUE, if the mechanical configuration of the crank permits a full turn, FALSE otherwise *)\nstCrankModuleItf.stCrank.lrXMechMin\t\t\t\t:= 0;\t\t\t(* Low end of linearized forward move *)\nstCrankModuleItf.stCrank.lrXMechMax\t\t\t\t:= 0;\t\t\t(* High end of linearized forward move *)\nstCrankModuleItf.stCrank.lrPhiMin\t\t\t\t:= 0;\t\t\t(* Crank angle for Xmin *)\nstCrankModuleItf.stCrank.lrPhiMax\t\t\t\t:= 0;\t\t\t(* Crank angle for Xmax *)\nstCrankModuleItf.stCrank.lrPhiXMechMin\t\t\t:= 0;\t\t\t(* Crank angle for XMechMin *)\nstCrankModuleItf.stCrank.lrPhiXMechMax\t\t\t:= 0;\t\t\t(* Crank angle for XMechMax  *)\n\n(* Calculated logical crank data *)\nstCrankModuleItf.stCrank.lrXLogMin\t\t\t\t:= 0;\nstCrankModuleItf.stCrank.lrXLogSwitch\t\t\t:= 0;\nstCrankModuleItf.stCrank.lrXLogMax\t\t\t\t:= 0;\nstCrankModuleItf.stCrank.lrPhiLogMin\t\t\t:= 0;\nstCrankModuleItf.stCrank.lrPhiLogSwitch\t\t\t:= 0;\nstCrankModuleItf.stCrank.lrPhiLogMax\t\t\t:= 0;\nstCrankModuleItf.stCrank.xXLogDirPos\t\t\t:= FALSE;\n\n(* Calculated P5 data *)\nstCrankModuleItf.stCrank.diP5NumberOfPoles\t\t:= 0;\n\n(* Internal Data *)\nstCrankModuleItf.stCrank.xValidData\t\t\t\t:= FALSE;\t\t(* Set if calculation was ok *)\nstCrankModuleItf.stCrank.xSynchron\t\t\t\t:= FALSE;\n\n(* End of system generated code, could be modified for your application*)\n","LineInfoPersistence":"(string)868588f0-7753-4119-92f1-621c59e1ad55_Impl_LineIds"}}}},"UniqueIdGenerator":"(string)597"}},"TypeInfos":{"3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","8ac092e5":"{8ac092e5-3128-4e26-9e7e-11016c6684f2}","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}