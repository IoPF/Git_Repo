{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)55dece67-503d-47cc-994d-ea132f9266bd","ParentGuid":"(Guid)82e749ab-50e2-4743-bacb-f425c721768a","Name":"(string)Init_Slave4","Properties":{"@Type":"2c41fa04:IDictionary","@Value":{}},"TypeGuid":"(Guid)8ac092e5-3128-4e26-9e7e-11016c6684f2","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"8ac092e5","@Value":{"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)(* System generated code, could be modified for your application *)\n\n(* Standard interface *)\nastSubModuleInterface[c_udiSlave4].i_sModuleName\t\t:= CONCAT(STR1 := iq_stStandardModuleItf.i_sModuleName, STR2 := ': Slave4');\n\nastSubModuleInterface[c_udiSlave4].i_xLogEnable\t\t\t:= \tTRUE;\nastSubModuleInterface[c_udiSlave4].i_wLogDataFilter\t\t:= \tUDINT_TO_WORD(TPL.ET_LogDataFilter.ModuleDefault);\n\n(* AxisModule specific interface *)\nstSlave4Interface.stMain.i_ifMaster\t\t\t:= i_ifMaster; \t\t(* Master *)\nstSlave4Interface.stMain.i_ifDrive\t\t\t:= DRV_Slave4;\nstSlave4Interface.stMain.iq_lencEncoder\t\t:= LE_Slave4;\n\n\nxDriveIsVirtual := FC_IsDriveVirtual(\ti_ifDrive\t:= stSlave4Interface.stMain.i_ifDrive,\n\t\t\t\t\t\t\t\t\t\tq_etDiag\t=> etDiag,\n\t\t\t\t\t\t\t\t\t\tq_etDiagExt\t=> etDiagExt, //etDiagExtTPL,\n\t\t\t\t\t\t\t\t\t\tq_sMsg\t\t=> sMsgBuffer);\n\nIF etDiag <> GD.ET_Diag.Ok AND NOT xIsDriveVirtualException THEN\t\t\t\t\t\t\t\t\t\t\n\tstIsDriveVirtualException.sMsg := sMsgBuffer;\n\txIsDriveVirtualException := TRUE;\nEND_IF\n\nTPL.FC_SetException(i_xExceptionActive\t:= xIsDriveVirtualException, \n\t\t\t\t\tiq_stException\t\t:= stIsDriveVirtualException, \n\t\t\t\t\tiq_stExceptionList\t:= iq_stExceptionList, \n\t\t\t\t\tiq_stLogDataList\t:= iq_stLogDataList);\n\t\t\t\t\t\nxInitSuccessful := xInitSuccessful AND NOT xIsDriveVirtualException;\netDiag := GD.ET_Diag.Ok;\n\t\n\n(*Set DeadTime compensation parameters depending on used type of Master*)\nFC_SetDeadTimeCompensation(i_stSubModuleInterfaceMain := stSlave4Interface.stMain);\n  (*Please note, FC_DeadTimeCompensation does not recognize the master type, transferred via C2C or encoder network! \n\tstXXXXInterface.stMain.iq_lencEncoder.Delay must be adjusted in order to reach shaft synchronism, it depends on:\n\t- Transmission delay via the choosen network, depending on topology and timing \n\t- Type of the master e.g. physical encoder or an axis\n\t- SERCOS cycle times in master and slave controllers\n\t\n\tC2C sample (similar for encoder network):\n\t//Access C2C_EncIn.DataDelay only if C2C_Master.SyncGroupState=5 or C2C_Slave.SyncGroupState = 5 and C2C_EncIn.DataValid = TRUE!\n\n\t\t//Master is a physical encoder (PMEnc/Inc):\n\t\t\tstXXXXInterface.stMain.iq_lencEncoder.Delay := C2C_EncIn.DataDelay - DRV_SlaveAxis.ShaftRefDelay;\n\n\t\t//Master is an axis (real/ virtual):\n\t\t\tstXXXXInterface.stMain.iq_lencEncoder.Delay := C2C_EncIn.DataDelay + one SERCOS cycle of C2C controller with connected master axis;*)\n\n\nxFirstCall := TRUE;\t\t// Used in Logic_Action to start movement in first cycle when OpMode is AXM.ET_OpMode.Positioning\n\nstSlave4Interface.stMain.i_lrMotionActiveVelLimit\t\t\t\t\t\t:= 15.0;\t(* Limit for max. velocity of astAxisModuleInterface to switch output AxisMove in Units/s *)\nstSlave4Interface.stMain.i_etMotionActiveVelType\t\t\t\t\t\t:= AXM.ET_MotionActiveVelType.Velocity;\n\nstSlave4Interface.stMain.i_timMasterStop\t\t\t\t\t\t\t\t:= T#1S;\nstSlave4Interface.stMain.i_xHwLimitPos\t\t\t\t\t\t\t\t\t:= FALSE;\nstSlave4Interface.stMain.i_xHwLimitNeg\t\t\t\t\t\t\t\t\t:= FALSE;\n\nstSlave4Interface.stMain.stReducedVelocity.i_xEnableReducedVelocity\t\t:= FALSE;\nstSlave4Interface.stMain.stReducedVelocity.i_xOnlyLimitCheck\t\t\t:= FALSE;\nstSlave4Interface.stMain.stReducedVelocity.i_lrMaxReducedVelocity\t\t:= 50.0;\n\nstSlave4Interface.stMain.i_xStart\t\t\t\t\t\t\t\t\t\t:= FALSE;\n\n(***************************************************************************************************************************************************************************************************)\n\n(*** Homing ***)\n\nIF xDriveIsVirtual THEN\n\tstSlave4Interface.stHome.i_etMode := PDL.ET_HomeMode.SetPosAxisAndLogEncoderPosition;\t\t\t(* Homing Mode  in case of virtual axis *)\nELSE\n\tstSlave4Interface.stHome.i_etMode := PDL.ET_HomeMode.PosDirectionPosEdgeTp;\t\t\t\t\t\t(* Homing Mode in case of real axis *)\nEND_IF\n\n\nstSlave4Interface.stHome.i_xEnableInitAbsReadPos := FALSE;\t\t(* TRUE : Restores the AxisPosition depending on the stHome.etMode\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  If stHome.i_etMode is equal to PDL.ET_HomeMode.RestorePosFromAxisEncoder or \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  to PDL.ET_HomeMode.WriteAxisEncoder, the encoder of the axis is read,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  or else the position will be restored from the retain area *)\n\t\t\t\t\t\t   \nstSlave4Interface.stHome.stSetpos.iq_pstRestorePosRetain := ADR(Grp_stRestorePositionAxis5);\n\nstSlave4Interface.stHome.i_xResetHomeOk := FALSE;\n\n(* Possible modes for homing mode Sensor:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeSensor\n\tPDL.ET_HomeMode.NegDirectionPosEdgeSensor\n\tPDL.ET_HomeMode.NegDirectionNegEdgeSensor\n\tPDL.ET_HomeMode.PosDirectionNegEdgeSensor\n*)\nstSlave4Interface.stHome.stSensor.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave4Interface.stHome.stSensor.i_lrVel\t\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstSlave4Interface.stHome.stSensor.i_lrAcc\t\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstSlave4Interface.stHome.stSensor.i_lrDec\t\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstSlave4Interface.stHome.stSensor.i_lrJerk\t\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstSlave4Interface.stHome.stSensor.i_lrOffset\t\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstSlave4Interface.stHome.stSensor.i_lrMaxTravel\t\t\t\t:= 720.0;\t\t(* Max. travel for referencing by normal input *)\nstSlave4Interface.stHome.stSensor.i_xRotativeSystem\t\t\t:= FALSE;\t\t(* Rotative system true or false for referencing by normal input *)\nstSlave4Interface.stHome.stSensor.i_xSensor\t\t\t\t\t:= FALSE;\t\t(* Input for home signal. Can be a signal from a controller input. Has to be written cyclic. *)\n\n(* Possible Modes for homing mode LimitSwitch:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeHWLimitPos\t\tnormally open contact / Closing contact\n\tPDL.ET_HomeMode.NegDirectionPosEdgeHWLimitNeg\t\tnormally open contact / Closing contact\n\tPDL.ET_HomeMode.NegDirectionNegEdgeHWLimitNeg\t\tnormally closed contact / Opening contact  \n\tPDL.ET_HomeMode.PosDirectionNegEdgeHWLimitPos\t\tnormally closed contact / Opening contact \n*)\nstSlave4Interface.stHome.stLimitSwitch.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave4Interface.stHome.stLimitSwitch.i_lrVel\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstSlave4Interface.stHome.stLimitSwitch.i_lrLowVel\t\t\t:= 5.0;\t\t\t(* Homing low ceiling velocity in units/s *)\nstSlave4Interface.stHome.stLimitSwitch.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstSlave4Interface.stHome.stLimitSwitch.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstSlave4Interface.stHome.stLimitSwitch.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstSlave4Interface.stHome.stLimitSwitch.i_lrOffset\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstSlave4Interface.stHome.stLimitSwitch.i_lrMaxTravel\t\t:= 9999.0;\t\t(* Max. travel for referencing normal input as a hardware limit *)\n\n(* Possible modes for homing mode MoveOnPos:\n\tPDL.ET_HomeMode.MoveOnPosAbs \n*)\nstSlave4Interface.stHome.stMoveonPos.i_lrTarget\t\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave4Interface.stHome.stMoveonPos.i_lrVel\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstSlave4Interface.stHome.stMoveonPos.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstSlave4Interface.stHome.stMoveonPos.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstSlave4Interface.stHome.stMoveonPos.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstSlave4Interface.stHome.stMoveonPos.i_lrPeriod\t\t\t\t:= 0.0;\t\t\t(* Period of the axis *)\nstSlave4Interface.stHome.stMoveonPos.i_xRotativeSystem\t\t:= FALSE;\t\t(* Rotative system true or false *)\n\n(* Possible modes for homing mode SetPos:\n\tPDL.ET_HomeMode.SetPosAxisPosition \n\tPDL.ET_HomeMode.SetPosLogEncoderPosition \n\tPDL.ET_HomeMode.SetPosAxisAndLogEncoderPosition\n\tPDL.ET_HomeMode.RestorePosFromAxisEncoder \n\tPDL.ET_HomeMode.RestorePosFromRetain \n*)\nstSlave4Interface.stHome.stSetpos.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave4Interface.stHome.stSetpos.i_lrEncoderPosition\t\t:= 0.0;\t\t\t(* Encoder position in units after homing *)\nstSlave4Interface.stHome.stSetpos.i_lrAbsEncOffset\t\t\t:= 100.0;\t\t(* Distance to the jump of axis encoder in units  *)\nstSlave4Interface.stHome.stSetpos.i_lrRestoreWindow\t\t\t:= 180;\t\t\t(* How far can the drive be away from is correct position *)\nstSlave4Interface.stHome.stSetpos.i_lrUserPeriod\t\t\t:= 360;\t\t\t(* Period of the axis *)\n\n(* Possible modes for homing mode Torque:\n\tPDL.ET_HomeMode.PosDirectionMaxTorque \n\tPDL.ET_HomeMode.NegDirectionMaxTorque \n*)\nstSlave4Interface.stHome.stTorque.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave4Interface.stHome.stTorque.i_lrVel\t\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstSlave4Interface.stHome.stTorque.i_lrAcc\t\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstSlave4Interface.stHome.stTorque.i_lrDec\t\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstSlave4Interface.stHome.stTorque.i_lrJerk\t\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstSlave4Interface.stHome.stTorque.i_lrOffset\t\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstSlave4Interface.stHome.stTorque.i_lrMaxTravel\t\t\t\t:= 9999.0;\t\t(* Max. travel for referencing by torque *)\nstSlave4Interface.stHome.stTorque.i_lrMaxTorque\t\t\t\t:= 0.0;\t\t\t(* Torque for stop in Nm / referencing by torque *)\nstSlave4Interface.stHome.stTorque.i_diTorqueTime\t\t\t:= 5;\t\t\t(* Time in msec to hold torque *)\n\n(* Possible modes for homing mode TouchProbe:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeTp \n\tPDL.ET_HomeMode.NegDirectionPosEdgeTp \n\tPDL.ET_HomeMode.NegDirectionNegEdgeTp \n\tPDL.ET_HomeMode.PosDirectionNegEdgeTp \n*)\nstSlave4Interface.stHome.stTouchProbe.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave4Interface.stHome.stTouchProbe.i_lrVel\t\t\t\t:= 100.0;\t\t(* Homing ceiling velocity in units/s *)\nstSlave4Interface.stHome.stTouchProbe.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstSlave4Interface.stHome.stTouchProbe.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstSlave4Interface.stHome.stTouchProbe.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstSlave4Interface.stHome.stTouchProbe.i_lrOffset\t\t\t:= 30.0;\t\t(* Offset from home signal in units *)\nstSlave4Interface.stHome.stTouchProbe.i_lrMaxTravel\t\t\t:= 720.0;\t\t(* Max. travel for referencing by TP *)\nstSlave4Interface.stHome.stTouchProbe.i_xRotativeSystem\t\t:= TRUE;\t\t(* Rotative system true or false for referencing by TP *)\nstSlave4Interface.stHome.stTouchProbe.i_ifTouchProbe\t\t:= TP_4;\t\t(* Input for TP *)\n\n(* Possible modes for homing mode WritePos:\n\tPDL.ET_HomeMode.WriteAxisEncoder \n*)\nstSlave4Interface.stHome.stWritePos.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave4Interface.stHome.stWritePos.i_lrUserPeriod\t\t\t:= 0.0;\t\t\t(* Calculates Drive.position into period ( units ) *)\nstSlave4Interface.stHome.stWritePos.i_lrAbsEncOffset\t\t:= 100.0;\t\t(* Distance to the jump of axis encoder in units *)\n\n(***************************************************************************************************************************************************************************************************)\n(*** Manual ***)\n\nstSlave4Interface.stManual.i_lrVel\t\t\t\t\t\t\t\t:= 50.0;\t\t\t(* Velocity in units/s *)\nstSlave4Interface.stManual.i_lrAcc\t\t\t\t\t\t\t\t:= 100.0;\t\t\t(* Acceleration in units/s^2 *)\nstSlave4Interface.stManual.i_lrDec\t\t\t\t\t\t\t\t:= 100.0;\t\t\t(* Deceleration in units/s^2 *)\nstSlave4Interface.stManual.i_lrJerk\t\t\t\t\t\t\t\t:= 1000.0;\t\t\t(* Jerk in units/s^3 *)\nstSlave4Interface.stManual.i_lrMaxDistance\t\t\t\t\t\t:= 120.0;\t\t\t(* Max pathlengths for one step in units *)\nstSlave4Interface.stManual.i_xEndless\t\t\t\t\t\t\t:= FALSE;\t\t\t(* TRUE: jogging endless; Position between the periode; FALSE: jogging in steps. Position can be out of periode *)\nstSlave4Interface.stManual.i_lrPeriod\t\t\t\t\t\t\t:= 360.0;\t\t\t(* Period of the axis *)\n\n(***************************************************************************************************************************************************************************************************)\n(*** Cam ***)\n\nstSlave4Interface.stMultiCam.i_etCSModeSlave\t\t\t\t\t:= PDL.ET_MultiCamCsModeSlave.SetSlavePositionToFirstCamPosition;\t\t(* ColdStartMode Slave *)\nstSlave4Interface.stMultiCam.i_etCSModeMaster\t\t\t\t\t:= PDL.ET_MultiCamCsModeMaster.SetMasterPositionToFirstCamPosition;\t\t(* ColdStartMode Master *)\nstSlave4Interface.stMultiCam.i_etWSMode\t\t\t\t\t\t\t:= PDL.ET_MultiCamWsMode.StoredCamMoveAlwaysNoPositionCheck;\t\t\t(* WarmStartMode *)\nstSlave4Interface.stMultiCam.i_lrWSWindow\t\t\t\t\t\t:= 5.0;\t\t\t\t\t\t\t\t\t\t\t(* WarmStartWindow in Axis units *)\nstSlave4Interface.stMultiCam.i_lrWSVel\t\t\t\t\t\t\t:= 10.0;\t\t\t\t\t\t\t\t\t\t(* Velocity for WarmStart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in Units/s *)\nstSlave4Interface.stMultiCam.i_lrWSAcc\t\t\t\t\t\t\t:= 1000.0;\t\t\t\t\t\t\t\t\t\t(* Acceleration and deceleration for Warmstart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in Units/s^2 *)\nstSlave4Interface.stMultiCam.i_lrWSJerk\t\t\t\t\t\t\t:= 10000.0;\t\t\t\t\t\t\t\t\t\t(* Jerk for Warmstart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in units/s^3 *)\nstSlave4Interface.stMultiCam.i_diTXend\t\t\t\t\t\t\t:= 2*SYSTEMINTERFACE.FC_LzsTaskGetInterval();\t(* Time of XLowEnd and XHighEnd befor Xend or Xstart in msec*)\nstSlave4Interface.stMultiCam.i_lrInstantXLimMax\t\t\t\t\t:= 0.0;\t\t\t\t\t\t\t\t\t\t\t(* Switch off position at 'InstantNewCam' *)\n\nstSlave4Interface.stMultiCam.i_xEnableTabHandler\t\t\t\t:= TRUE;\t\t\t\t\t\t\t\t\t\t(* TRUE: TabHandler is enabled *)\nstSlave4Interface.stMultiCam.i_udiTableSelectNr\t\t\t\t\t:= AXM.ET_ParId.User;\t\t\t\t\t\t\t(* Number of table which is used in the next cycle *)\t\t\t\t\t\t\t\t\n\nstSlave4Interface.stMultiCam.i_xSetEncoderParameters\t\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: The parameters MasterId, FeedConstand, GearIn and GearOut will be copyed into LEnc object *)\nstSlave4Interface.stMultiCam.i_xSetEncoderPosition\t\t\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: Manipulation of LEnc object on startup OpMode MultiCam *)\nstSlave4Interface.stMultiCam.i_lrSetEncoderOffset\t\t\t\t:= 0.0;\t\t\t\t\t\t\t\t\t\t\t(* Master encoder offset *)\nstSlave4Interface.stMultiCam.i_xCheckEncoderPeriod\t\t\t\t:= TRUE;\t\t\t\t\t\t\t\t\t\t(* TRUE: Check of encoder period = 0. If encoder period <> 0 -> Exception *)\n\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].diNumberOfCamPoints\t\t:= 4;\t(* DataStruct for the next cycle *)\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].lrYPeriod\t\t\t\t:= 0.0;\n\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrX\t\t:= 0.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrY\t\t:= 0.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrM\t\t:= 0.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].etCamType\t:= PDL.ET_CamType.Poly5Com;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrX\t\t:= 60.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrY\t\t:= 30.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrM\t\t:= 1.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].etCamType\t:= PDL.ET_CamType.Straight;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrX\t\t:= 240.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrY\t\t:= 210.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrM\t\t:= 1.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].etCamType\t:= PDL.ET_CamType.Poly5Com;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrX\t\t:= 360.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrY\t\t:= 0.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrM\t\t:= 0.0;\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].etCamType\t:= PDL.ET_CamType.Poly5Com;\n\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Idle].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Idle);\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Start].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Start);\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Cont].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Cont);\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Stop].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.Stop);\nstSlave4Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].diUserTableId\t:= UDINT_TO_DINT(AXM.ET_ParId.User);\n\n\n(***************************************************************************************************************************************************************************************************)\n(*** Endless ***)\n\nstSlave4Interface.stEndless.i_lrVel\t\t\t\t\t\t\t\t:= 100.0;\t\t\t(* Velocity in Units/s *)\nstSlave4Interface.stEndless.i_lrAcc\t\t\t\t\t\t\t\t:= 1000.0;\t\t\t(* Acceleration in Units/s^2 *)\nstSlave4Interface.stEndless.i_lrDec\t\t\t\t\t\t\t\t:= 1000.0;\t\t\t(* Deceleration in Units/s^2 *)\nstSlave4Interface.stEndless.i_lrJerk\t\t\t\t\t\t\t:= 10000.0;\t\t\t(* Jerk in units/s^3 *)\nstSlave4Interface.stEndless.i_lrPeriod\t\t\t\t\t\t\t:= 360.0;\t\t\t(* Period one cycle in units *)\nstSlave4Interface.stEndless.i_lrStopPosition\t\t\t\t\t:= 0.5;\t\t\t\t(* Stop position in units *)\n\n\n(***************************************************************************************************************************************************************************************************)\n(*** Pos ***)\n\nstSlave4Interface.stPos.i_etPosMode\t\t\t\t\t\t\t\t:= SYSTEMINTERFACE.ET_PosMode.Endless;\t\t(* SYSTEMINTERFACE.ET_PosMode.Endless, SYSTEMINTERFACE.ET_PosMode.Relative, SYSTEMINTERFACE.ET_PosMode.Absolute *)\nstSlave4Interface.stPos.i_lrTarget\t\t\t\t\t\t\t\t:= 360.0;\t\t\t\t\t\t\t\t\t(* Target position or distance in Units *)\nstSlave4Interface.stPos.i_lrVel\t\t\t\t\t\t\t\t\t:= 100.0;\t\t\t\t\t\t\t\t\t(* Ceiling velocity in Units/s *)\nstSlave4Interface.stPos.i_lrAcc\t\t\t\t\t\t\t\t\t:= 3600.0;\t\t\t\t\t\t\t\t\t(* Acceleration in Units/s^2 *)\nstSlave4Interface.stPos.i_lrDec\t\t\t\t\t\t\t\t\t:= 3600.0;\t\t\t\t\t\t\t\t\t(* Deceleration in Units/s^2 *)\nstSlave4Interface.stPos.i_lrJerk\t\t\t\t\t\t\t\t:= 36000.0;\t\t\t\t\t\t\t\t\t(* Jerk in units/s^3 *)\n\n(* End of system generated code, could be modified for your application *)\n","LineInfoPersistence":"(string)55dece67-503d-47cc-994d-ea132f9266bd_Impl_LineIds"}}}},"UniqueIdGenerator":"(string)738"}},"TypeInfos":{"3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","8ac092e5":"{8ac092e5-3128-4e26-9e7e-11016c6684f2}","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}