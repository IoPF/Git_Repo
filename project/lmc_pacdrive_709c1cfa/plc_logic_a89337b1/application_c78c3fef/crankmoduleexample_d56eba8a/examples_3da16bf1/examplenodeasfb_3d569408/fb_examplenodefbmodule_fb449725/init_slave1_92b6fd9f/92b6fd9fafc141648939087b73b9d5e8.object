{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)92b6fd9f-afc1-4164-8939-087b73b9d5e8","ParentGuid":"(Guid)fb449725-3b7d-406f-8fa4-50c2a16b0595","Name":"(string)Init_Slave1","Properties":{"@Type":"2c41fa04:IDictionary","@Value":{}},"TypeGuid":"(Guid)8ac092e5-3128-4e26-9e7e-11016c6684f2","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"8ac092e5","@Value":{"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)(* System generated code, could be modified for your application *)\n\n(* Standard interface *)\nastSubModuleInterface[c_udiSlave1].i_sModuleName\t\t:= CONCAT(STR1 := iq_stStandardModuleItf.i_sModuleName, STR2 := ': Slave1');\n\nastSubModuleInterface[c_udiSlave1].i_xLogEnable\t\t:= \tTRUE;\nastSubModuleInterface[c_udiSlave1].i_wLogDataFilter\t:=\tUDINT_TO_WORD(TPL.ET_LogDataFilter.ModuleDefault);\n\n(* Axis main drive / EndlessFeed*)\nstSlave1Interface.stMain.i_ifMaster\t\t:= i_ifMaster; \t\t(* Master *)\nstSlave1Interface.stMain.i_ifDrive\t\t:= iq_stAdditionalItf.i_ifSlave1;\nstSlave1Interface.stMain.iq_lencEncoder\t:= iq_stAdditionalItf.i_lencEncoder1;\n\n\nxDriveIsVirtual := FC_IsDriveVirtual(\ti_ifDrive\t:= stSlave1Interface.stMain.i_ifDrive,\n\t\t\t\t\t\t\t\t\t\tq_etDiag\t=> etDiag,\n\t\t\t\t\t\t\t\t\t\tq_etDiagExt\t=> etDiagExtTPL,\n\t\t\t\t\t\t\t\t\t\tq_sMsg\t\t=> sMsgBuffer);\n\nIF etDiag <> GD.ET_Diag.Ok AND NOT xIsDriveVirtualException THEN\t\t\t\t\t\t\t\t\t\t\n\tstIsDriveVirtualException.sMsg := sMsgBuffer;\n\txIsDriveVirtualException := TRUE;\nEND_IF\n\nTPL.FC_SetException(i_xExceptionActive\t:= xIsDriveVirtualException, \n\t\t\t\t\tiq_stException\t\t:= stIsDriveVirtualException, \n\t\t\t\t\tiq_stExceptionList\t:= iq_stExceptionList, \n\t\t\t\t\tiq_stLogDataList\t:= iq_stLogDataList);\n\t\t\t\t\t\nxInitSuccessful := xInitSuccessful AND NOT xIsDriveVirtualException;\netDiag := GD.ET_Diag.Ok;\n\t\n\nIF stSlave1Interface.stMain.i_ifMaster <> 0 THEN\t\n\tstLogicalAddressMaster := stSlave1Interface.stMain.i_ifMaster.stLogicalAddress;\n\tIF (stLogicalAddressMaster.udiType = SYSTEMINTERFACE.P_ENC_TYPE.udiType) OR\t\t\t(* Physical encoder *)\n\t\t(stLogicalAddressMaster.udiType = SYSTEMINTERFACE.INC_IN_TYPE.udiType) THEN\t\t(* Incremental\tencoder *)\n\t\t\n\t\tstLogicalAddressMaster.udiParameterId := 16#00A2;\n\t\tdiResult := SYSTEMINTERFACE.FC_GetParameter(i_stLogAdr\t:= stLogicalAddressMaster,\n\t\t\t\t\t\t\t\t\t\t\t\t\ti_dwBuffer\t:= ADR(lrShaftRefDelay),\n\t\t\t\t\t\t\t\t\t\t\t\t\ti_diSize\t:= SIZEOF(lrShaftRefDelay));\n\t\tIF diResult = 0 THEN\n\t\t\tstSlave1Interface.stMain.iq_lencEncoder.Delay := -lrShaftRefDelay;\n\t\tEND_IF\n\tEND_IF\nEND_IF\n\n\nstSlave1Interface.stMain.i_lrMotionActiveVelLimit\t\t\t\t\t\t:= 15.0;\t\t(* Limit for max. velocity of astAxisModuleInterface to switch output AxisMove in Units/s *)\nstSlave1Interface.stMain.i_etMotionActiveVelType\t\t\t\t\t\t:= AXM.ET_MotionActiveVelType.Velocity;\n\nstSlave1Interface.stMain.i_timMasterStop\t\t\t\t\t\t\t\t:= T#1S;\nstSlave1Interface.stMain.i_xHwLimitPos\t\t\t\t\t\t\t\t\t:= FALSE;\nstSlave1Interface.stMain.i_xHwLimitNeg\t\t\t\t\t\t\t\t\t:= FALSE;\n\nstSlave1Interface.stMain.stReducedVelocity.i_xEnableReducedVelocity\t\t:= FALSE;\nstSlave1Interface.stMain.stReducedVelocity.i_xOnlyLimitCheck\t\t\t:= FALSE;\nstSlave1Interface.stMain.stReducedVelocity.i_lrMaxReducedVelocity\t\t:= 50.0;\n\nstSlave1Interface.stMain.i_xStart\t\t\t\t\t\t\t\t\t\t:= FALSE;\n\n(***************************************************************************************************************************************************************************************************)\n\n(*** Homing ***)\n\nIF xDriveIsVirtual THEN\n\tstSlave1Interface.stHome.i_etMode := PDL.ET_HomeMode.SetPosAxisAndLogEncoderPosition;\t\t(* Homing Mode in case of virtual axis *)\nELSE\n\tstSlave1Interface.stHome.i_etMode := PDL.ET_HomeMode.PosDirectionPosEdgeTp;\t\t\t\t\t(* Homing Mode in case of real axis *)\nEND_IF\n\n\nstSlave1Interface.stHome.i_xEnableInitAbsReadPos := TRUE;\t\t(* TRUE : Restores the AxisPosition depending on the stHome.etMode\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  If stHome.i_etMode is equal to PDL.ET_HomeMode.RestorePosFromAxisEncoder or \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  to PDL.ET_HomeMode.WriteAxisEncoder, the encoder of the axis is read,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  or else the position will be restored from the retain area *)\n\nstSlave1Interface.stHome.stSetpos.iq_pstRestorePosRetain := iq_stAdditionalItf.i_pstRestorePosRetain1;\n\nstSlave1Interface.stHome.i_xResetHomeOk := FALSE;\n\n(* Possible modes for homing mode Sensor:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeSensor\n\tPDL.ET_HomeMode.NegDirectionPosEdgeSensor\n\tPDL.ET_HomeMode.NegDirectionNegEdgeSensor\n\tPDL.ET_HomeMode.PosDirectionNegEdgeSensor\n*)\nstSlave1Interface.stHome.stSensor.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave1Interface.stHome.stSensor.i_lrVel\t\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstSlave1Interface.stHome.stSensor.i_lrAcc\t\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstSlave1Interface.stHome.stSensor.i_lrDec\t\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstSlave1Interface.stHome.stSensor.i_lrJerk\t\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstSlave1Interface.stHome.stSensor.i_lrOffset\t\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstSlave1Interface.stHome.stSensor.i_lrMaxTravel \t\t\t:= 720.0;\t\t(* Max. travel for referencing by normal input *)\nstSlave1Interface.stHome.stSensor.i_xRotativeSystem\t\t\t:= FALSE;\t\t(* Rotative system true or false for referencing by normal input *)\nstSlave1Interface.stHome.stSensor.i_xSensor \t\t\t\t:= FALSE;\t\t(* Input for home signal. Can be a signal from a controller input. Has to be written cyclic. *)\n\n(* Possible Modes for homing mode LimitSwitch:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeHWLimitPos\t\tnormally open contact / Closing contact\n\tPDL.ET_HomeMode.NegDirectionPosEdgeHWLimitNeg\t\tnormally open contact / Closing contact\n\tPDL.ET_HomeMode.NegDirectionNegEdgeHWLimitNeg\t\tnormally closed contact / Opening contact  \n\tPDL.ET_HomeMode.PosDirectionNegEdgeHWLimitPos\t\tnormally closed contact / Opening contact \n*)\nstSlave1Interface.stHome.stLimitSwitch.i_lrHomePosition \t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave1Interface.stHome.stLimitSwitch.i_lrVel\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstSlave1Interface.stHome.stLimitSwitch.i_lrLowVel\t\t\t:= 5.0;\t\t\t(* Homing low ceiling velocity in units/s *)\nstSlave1Interface.stHome.stLimitSwitch.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstSlave1Interface.stHome.stLimitSwitch.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstSlave1Interface.stHome.stLimitSwitch.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstSlave1Interface.stHome.stLimitSwitch.i_lrOffset\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstSlave1Interface.stHome.stLimitSwitch.i_lrMaxTravel \t\t:= 9999.0;\t\t(* Max. travel for referencing normal input as a hardware limit *)\n\n(* Possible modes for homing mode MoveOnPos:\n\tPDL.ET_HomeMode.MoveOnPosAbs \n*)\nstSlave1Interface.stHome.stMoveOnPos.i_lrTarget\t\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave1Interface.stHome.stMoveOnPos.i_lrVel\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstSlave1Interface.stHome.stMoveOnPos.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstSlave1Interface.stHome.stMoveOnPos.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstSlave1Interface.stHome.stMoveOnPos.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstSlave1Interface.stHome.stMoveOnPos.i_lrPeriod\t\t\t\t:= 0.0;\t\t\t(* Period of the axis *)\nstSlave1Interface.stHome.stMoveOnPos.i_xRotativeSystem\t\t:= FALSE;\t\t(* Rotative system true or false *)\n\n(* Possible modes for homing mode SetPos:\n\tPDL.ET_HomeMode.SetPosAxisPosition \n\tPDL.ET_HomeMode.SetPosLogEncoderPosition \n\tPDL.ET_HomeMode.SetPosAxisAndLogEncoderPosition\n\tPDL.ET_HomeMode.RestorePosFromAxisEncoder \n\tPDL.ET_HomeMode.RestorePosFromRetain \n*)\nstSlave1Interface.stHome.stSetpos.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave1Interface.stHome.stSetpos.i_lrEncoderPosition\t\t:= 0.0;\t\t\t(* Encoder position in units after homing *)\nstSlave1Interface.stHome.stSetpos.i_lrAbsEncOffset\t\t\t:= 100.0;\t\t(* Distance to the jump of axis encoder in units *)\nstSlave1Interface.stHome.stSetpos.i_lrRestoreWindow\t\t\t:= 180;\t\t\t(* How far can the drive be away from its correct position *)\nstSlave1Interface.stHome.stSetpos.i_lrUserPeriod\t\t\t:= 360;\t\t\t(* Period of the axis *)\n\n(* Possible modes for homing mode Torque:\n\tPDL.ET_HomeMode.PosDirectionMaxTorque \n\tPDL.ET_HomeMode.NegDirectionMaxTorque \n*)\nstSlave1Interface.stHome.stTorque.i_lrHomePosition\t\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave1Interface.stHome.stTorque.i_lrVel\t\t\t\t\t:= 10.0;\t\t(* Homing ceiling velocity in units/s *)\nstSlave1Interface.stHome.stTorque.i_lrAcc\t\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstSlave1Interface.stHome.stTorque.i_lrDec\t\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstSlave1Interface.stHome.stTorque.i_lrJerk\t\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstSlave1Interface.stHome.stTorque.i_lrOffset\t\t\t\t:= 0.0;\t\t\t(* Offset from home signal in units *)\nstSlave1Interface.stHome.stTorque.i_lrMaxTravel\t\t\t\t:= 9999.0;\t\t(* Max. travel for referencing by torque *)\nstSlave1Interface.stHome.stTorque.i_lrMaxTorque\t\t\t\t:= 0.0;\t\t\t(* Torque for stop in Nm / referencing by torque *)\nstSlave1Interface.stHome.stTorque.i_diTorqueTime\t\t\t:= 5;\t\t\t(* Time in msec to hold torque *)\n\n(* Possible modes for homing mode TouchProbe:\n\tPDL.ET_HomeMode.PosDirectionPosEdgeTp \n\tPDL.ET_HomeMode.NegDirectionPosEdgeTp \n\tPDL.ET_HomeMode.NegDirectionNegEdgeTp \n\tPDL.ET_HomeMode.PosDirectionNegEdgeTp \n*)\nstSlave1Interface.stHome.stTouchProbe.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave1Interface.stHome.stTouchProbe.i_lrVel\t\t\t\t:= 100.0;\t\t(* Homing ceiling velocity in units/s *)\nstSlave1Interface.stHome.stTouchProbe.i_lrAcc\t\t\t\t:= 1000.0;\t\t(* Homing acceleration in units/s^2 *)\nstSlave1Interface.stHome.stTouchProbe.i_lrDec\t\t\t\t:= 1000.0;\t\t(* Homing deceleration in units/s^2 *)\nstSlave1Interface.stHome.stTouchProbe.i_lrJerk\t\t\t\t:= 10000.0;\t\t(* Homing jerk in units/s^3 *)\nstSlave1Interface.stHome.stTouchProbe.i_lrOffset\t\t\t:= 30.0;\t\t(* Offset from home signal in units *)\nstSlave1Interface.stHome.stTouchProbe.i_lrMaxTravel\t\t\t:= 720.0;\t\t(* Max. travel for referencing by TP *)\nstSlave1Interface.stHome.stTouchProbe.i_xRotativeSystem\t\t:= TRUE;\t\t(* Rotative system true or false for referencing by TP *)\nstSlave1Interface.stHome.stTouchProbe.i_ifTouchProbe\t\t:= iq_stAdditionalItf.i_ifHomingTouchProbe1;\t\t(* Input for TP *)\n\n(* Possible modes for homing mode WritePos:\n\tPDL.ET_HomeMode.WriteAxisEncoder \n*)\nstSlave1Interface.stHome.stWritePos.i_lrHomePosition\t\t:= 0.0;\t\t\t(* Position at the end of homing in units *)\nstSlave1Interface.stHome.stWritePos.i_lrUserPeriod\t\t\t:= 0.0;\t\t\t(* Calculates Drive.Position into period ( units ) *)\nstSlave1Interface.stHome.stWritePos.i_lrAbsEncOffset\t\t:= 100.0;\t\t(* Distance to the jump of axis encoder in units *)\n\n(***************************************************************************************************************************************************************************************************)\n(*** Manual ***)\n\nstSlave1Interface.stManual.i_lrVel\t\t\t\t\t\t\t\t:= 50.0;\t\t\t(* Velocity in units/s *)\nstSlave1Interface.stManual.i_lrAcc\t\t\t\t\t\t\t\t:= 100.0;\t\t\t(* Acceleration in units/s^2 *)\nstSlave1Interface.stManual.i_lrDec\t\t\t\t\t\t\t\t:= 100.0;\t\t\t(* Deceleration in units/s^2 *)\nstSlave1Interface.stManual.i_lrJerk\t\t\t\t\t\t\t\t:= 1000.0;\t\t\t(* Jerk in units/s^3 *)\nstSlave1Interface.stManual.i_lrMaxDistance\t\t\t\t\t\t:= 120.0;\t\t\t(* Max pathlengths for one step in units *)\nstSlave1Interface.stManual.i_xEndless\t\t\t\t\t\t\t:= FALSE;\t\t\t(* TRUE: jogging endless; Position between the periode; FALSE: jogging in steps. Position can be out of periode *)\nstSlave1Interface.stManual.i_lrPeriod\t\t\t\t\t\t\t:= 360.0;\t\t\t(* Period of the axis *)\n\n(***************************************************************************************************************************************************************************************************)\n(*** Cam ***)\n\nstSlave1Interface.stMultiCam.i_etCSModeSlave\t\t\t\t\t:= PDL.ET_MultiCamCsModeSlave.SetSlavePositionToFirstCamPosition;\t\t(* ColdStartMode Slave *)\nstSlave1Interface.stMultiCam.i_etCSModeMaster\t\t\t\t\t:= PDL.ET_MultiCamCsModeMaster.SetMasterPositionToFirstCamPosition;\t\t(* ColdStartMode Master *)\nstSlave1Interface.stMultiCam.i_etWSMode\t\t\t\t\t\t\t:= PDL.ET_MultiCamWsMode.StoredCamMoveAlwaysNoPositionCheck;\t\t\t(* WarmStartMode *)\nstSlave1Interface.stMultiCam.i_lrWSWindow\t\t\t\t\t\t:= 5.0;\t\t\t\t\t\t\t\t\t\t\t(* WarmStartWindow in Axis units *)\nstSlave1Interface.stMultiCam.i_lrWSVel\t\t\t\t\t\t\t:= 10.0;\t\t\t\t\t\t\t\t\t\t(* Velocity for WarmStart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in Units/s *)\nstSlave1Interface.stMultiCam.i_lrWSAcc\t\t\t\t\t\t\t:= 1000.0;\t\t\t\t\t\t\t\t\t\t(* Acceleration and deceleration for Warmstart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in Units/s^2 *)\nstSlave1Interface.stMultiCam.i_lrWSJerk\t\t\t\t\t\t\t:= 10000.0;\t\t\t\t\t\t\t\t\t\t(* Jerk for Warmstart and CSModeSlave = PDL.ET_MultiCamCsModeSlave.MoveSlaveToFirstCamPosition in units/s^3 *)\nstSlave1Interface.stMultiCam.i_diTXend\t\t\t\t\t\t\t:= 2*SYSTEMINTERFACE.FC_LzsTaskGetInterval();\t(* Time of XLowEnd and XHighEnd befor Xend or Xstart in msec*)\nstSlave1Interface.stMultiCam.i_lrInstantXLimMax\t\t\t\t\t:= 0.0;\t\t\t\t\t\t\t\t\t\t\t(* Switch off position at 'InstantNewCam' *)\n\nstSlave1Interface.stMultiCam.i_xEnableTabHandler\t\t\t\t:= TRUE;\t\t\t\t\t\t\t\t\t\t(* TRUE: TabHandler is enabled *)\nstSlave1Interface.stMultiCam.i_udiTableSelectNr\t\t\t\t\t:= AXM.ET_ParId.User;\t\t\t\t\t\t\t(* Number of table which is used in the next cycle *)\t\t\t\t\t\t\t\t\n\nstSlave1Interface.stMultiCam.i_xSetEncoderParameters\t\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: The parameters MasterId, FeedConstand, GearIn and GearOut will be copyed into LEnc object *)\nstSlave1Interface.stMultiCam.i_xSetEncoderPosition\t\t\t\t:= FALSE;\t\t\t\t\t\t\t\t\t\t(* TRUE: Manipulation of LEnc object on startup OpMode MultiCam *)\nstSlave1Interface.stMultiCam.i_lrSetEncoderOffset\t\t\t\t:= 0.0;\t\t\t\t\t\t\t\t\t\t\t(* Master encoder offset *)\nstSlave1Interface.stMultiCam.i_xCheckEncoderPeriod\t\t\t\t:= TRUE;\t\t\t\t\t\t\t\t\t\t(* TRUE: Check of encoder period = 0. If encoder period <> 0 -> Exception *)\n\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].diNumberOfCamPoints\t\t\t:= 4;\t(* DataStruct for the next cycle *)\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].lrYPeriod\t\t\t\t\t\t:= 0.0;\n\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrX\t\t\t:= 0.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrY\t\t\t:= 0.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].lrM\t\t\t:= 0.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[0].etCamType\t:= PDL.ET_CamType.Poly5Com;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrX\t\t\t:= 60.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrY\t\t\t:= 30.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].lrM\t\t\t:= 1.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[1].etCamType\t:= PDL.ET_CamType.Straight;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrX\t\t\t:= 240.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrY\t\t\t:= 210.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].lrM\t\t\t:= 1.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[2].etCamType\t:= PDL.ET_CamType.Poly5Com;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrX\t\t\t:= 360.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrY\t\t\t:= 0.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].lrM\t\t\t:= 0.0;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].astCamPoint[3].etCamType\t:= PDL.ET_CamType.Poly5Com;\n\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Idle].diUserTableId\t:= AXM.ET_ParId.Idle;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Start].diUserTableId\t:= AXM.ET_ParId.Start;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Cont].diUserTableId\t:= AXM.ET_ParId.Cont;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.Stop].diUserTableId\t:= AXM.ET_ParId.Stop;\nstSlave1Interface.stMultiCam.iq_astMotionPar[AXM.ET_ParId.User].diUserTableId\t:= AXM.ET_ParId.User;\n\n\n(***************************************************************************************************************************************************************************************************)\n(*** Endless ***)\n\nstSlave1Interface.stEndless.i_lrVel\t\t\t\t\t\t\t\t:= 100.0;\t\t\t(* Velocity in Units/s *)\nstSlave1Interface.stEndless.i_lrAcc\t\t\t\t\t\t\t\t:= 1000.0;\t\t\t(* Acceleration in Units/s^2 *)\nstSlave1Interface.stEndless.i_lrDec\t\t\t\t\t\t\t\t:= 1000.0;\t\t\t(* Deceleration in Units/s^2 *)\nstSlave1Interface.stEndless.i_lrJerk\t\t\t\t\t\t\t:= 10000.0;\t\t\t(* Jerk in units/s^3 *)\nstSlave1Interface.stEndless.i_lrPeriod\t\t\t\t\t\t\t:= 360.0;\t\t\t(* Period one cycle in units *)\nstSlave1Interface.stEndless.i_lrStopPosition\t\t\t\t\t:= 0.5;\t\t\t\t(* Stop position in units *)\n\n\n(***************************************************************************************************************************************************************************************************)\n(*** Pos ***)\n\nstSlave1Interface.stPos.i_etPosMode\t\t\t\t\t\t\t\t:= SYSTEMINTERFACE.ET_PosMode.Endless;\t\t(* SYSTEMINTERFACE.ET_PosMode.Endless, SYSTEMINTERFACE.ET_PosMode.Relative, SYSTEMINTERFACE.ET_PosMode.Absolute *)\nstSlave1Interface.stPos.i_lrTarget\t\t\t\t\t\t\t\t:= 360.0;\t\t\t\t\t\t\t\t\t(* Target position or distance in Units *)\nstSlave1Interface.stPos.i_lrVel\t\t\t\t\t\t\t\t\t:= 360.0;\t\t\t\t\t\t\t\t\t(* Ceiling velocity in Units/s *)\nstSlave1Interface.stPos.i_lrAcc\t\t\t\t\t\t\t\t\t:= 3600.0;\t\t\t\t\t\t\t\t\t(* Acceleration in Units/s^2 *)\nstSlave1Interface.stPos.i_lrDec\t\t\t\t\t\t\t\t\t:= 3600.0;\t\t\t\t\t\t\t\t\t(* Deceleration in Units/s^2 *)\nstSlave1Interface.stPos.i_lrJerk\t\t\t\t\t\t\t\t:= 36000.0;\t\t\t\t\t\t\t\t\t(* Jerk in units/s^3 *)\n\n\n(* End of system generated code, could be modified for your application *)\n","LineInfoPersistence":"(string)92b6fd9f-afc1-4164-8939-087b73b9d5e8_Impl_LineIds"}}}},"UniqueIdGenerator":"(string)811"}},"TypeInfos":{"3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","8ac092e5":"{8ac092e5-3128-4e26-9e7e-11016c6684f2}","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}